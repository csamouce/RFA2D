<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nodule Navigator: RFA Challenge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Apply the arcade font */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a2e; /* Dark blue background */
            color: #e0e0e0; /* Light gray text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden; /* Prevent scrollbars from game elements */
        }
        /* Style the canvas elements */
        canvas {
            background-color: #0f0f1f; /* Darker blue for canvas */
            border: 2px solid #4a4a7f; /* Purple border */
            border-radius: 8px;
            cursor: crosshair; /* Indicate interaction area */
        }
        /* Style buttons with arcade feel */
        button {
            font-family: 'Press Start 2P', cursive;
            background-color: #16a085; /* Teal */
            color: #ffffff;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #117a65; /* Button shadow for 3D effect */
            cursor: pointer;
            transition: all 0.1s ease;
            margin: 5px;
            text-transform: uppercase;
        }
        button:active {
            box-shadow: 0 2px #117a65;
            transform: translateY(2px);
        }
        button:disabled {
            background-color: #555;
            box-shadow: 0 4px #333;
            cursor: not-allowed;
        }
        /* Style the RF ON button specifically */
        #rfButton.on {
             background-color: #e74c3c; /* Red when ON */
             box-shadow: 0 4px #c0392b;
        }
         #rfButton.on:active {
             box-shadow: 0 2px #c0392b;
         }
        /* Style the message box */
        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(40, 40, 70, 0.9); /* Semi-transparent dark purple */
            color: #f1c40f; /* Yellow text */
            padding: 20px;
            border: 3px solid #f1c40f;
            border-radius: 10px;
            text-align: center;
            z-index: 100; /* Ensure it's on top */
            display: none; /* Hidden by default */
            font-size: 1.2em;
            box-shadow: 0 0 15px rgba(241, 196, 15, 0.5);
        }
        /* Style for different ablation states */
        .status-untouched { color: #95a5a6; } /* Gray */
        .status-incomplete { color: #e74c3c; } /* Red */
        .status-adequate { color: #2ecc71; } /* Green */
        .status-excessive { color: #7f8c8d; } /* Darker Gray */
        .warning { color: #f39c12; font-weight: bold; } /* Orange for warnings */

        /* Container for the game */
        .game-container {
            background-color: #2c2c54; /* Medium dark blue */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 95%;
            width: 1000px; /* Adjust width as needed */
        }
    </style>
</head>
<body>
    <div class="game-container w-full max-w-4xl mx-auto p-4 rounded-lg shadow-lg">
        <h1 class="text-2xl text-center mb-4 text-teal-300">Nodule Navigator: RFA Challenge</h1>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
            <div class="md:col-span-2 bg-gray-800 p-2 rounded shadow">
                <h2 class="text-lg text-center mb-2 text-cyan-300">Ultrasound View</h2>
                <canvas id="ultrasoundCanvas" width="600" height="400"></canvas>
            </div>

            <div class="bg-gray-800 p-4 rounded shadow flex flex-col justify-between">
                <div>
                    <h2 class="text-lg text-center mb-3 text-cyan-300">Controls & Metrics</h2>

                    <div class="text-center mb-4">
                        <h3 class="text-md mb-2 text-yellow-300">RF Generator</h3>
                        <button id="rfButton">RF OFF</button>
                        <div class="mt-2">
                            <label for="powerSlider" class="block text-sm mb-1">Power: <span id="powerValue">50</span>W</label>
                            <input type="range" id="powerSlider" min="10" max="100" value="50" step="5" class="w-full">
                        </div>
                    </div>

                    <div class="text-sm space-y-1">
                        <h3 class="text-md mb-2 text-yellow-300">Ablation Status</h3>
                        <p>Adequate: <span id="adequatePercent" class="status-adequate font-bold">0</span>%</p>
                        <p>Incomplete: <span id="incompletePercent" class="status-incomplete font-bold">0</span>%</p>
                        <p>Excessive: <span id="excessivePercent" class="status-excessive font-bold">0</span>%</p>
                        <p>Untouched: <span id="untouchedPercent" class="status-untouched font-bold">100</span>%</p>
                        <p class="mt-2">Score: <span id="score" class="font-bold text-white">0</span></p>
                        <p>Time Left: <span id="timer" class="font-bold text-white">60</span>s</p>
                    </div>
                </div>

                <div class="mt-4 text-center">
                     <button id="startButton">Start Game</button>
                     <button id="resetButton" disabled>Reset</button>
                 </div>
            </div>
        </div>

        <div class="bg-gray-800 p-2 rounded shadow mb-4">
             <h2 class="text-lg text-center mb-2 text-cyan-300">Simplified Anatomy</h2>
             <canvas id="anatomyCanvas" width="950" height="100"></canvas>
        </div>

         <div id="warningArea" class="text-center mt-2 h-6 text-yellow-400 font-bold"></div>

        <div id="messageBox">
            <p id="messageText"></p>
            <button id="closeMessageButton" class="mt-4">OK</button>
        </div>
    </div>

    <script>
        // --- Canvas Setup ---
        const ultrasoundCanvas = document.getElementById('ultrasoundCanvas');
        const usCtx = ultrasoundCanvas.getContext('2d');
        const anatomyCanvas = document.getElementById('anatomyCanvas');
        const anCtx = anatomyCanvas.getContext('2d');

        // --- Game Elements ---
        const rfButton = document.getElementById('rfButton');
        const powerSlider = document.getElementById('powerSlider');
        const powerValueSpan = document.getElementById('powerValue');
        const adequatePercentSpan = document.getElementById('adequatePercent');
        const incompletePercentSpan = document.getElementById('incompletePercent');
        const excessivePercentSpan = document.getElementById('excessivePercent');
        const untouchedPercentSpan = document.getElementById('untouchedPercent');
        const scoreSpan = document.getElementById('score');
        const timerSpan = document.getElementById('timer');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const warningArea = document.getElementById('warningArea');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessageButton = document.getElementById('closeMessageButton');

        // --- Game State Variables ---
        let gameActive = false;
        let rfActive = false;
        let score = 0;
        let timeLeft = 60; // seconds
        let timerInterval = null;
        let animationFrameId = null;
        let power = 50;
        let needlePos = { x: 50, y: 50 };
        let nodule = null;
        let criticalStructures = []; // { x, y, width, height, name }
        let voxels = []; // { x, y, size, state, ablationProgress }
        const voxelSize = 10; // Size of each voxel square
        let totalNoduleVoxels = 0;

        // Ablation constants (simplified)
        const ABLATION_RATE_FACTOR = 0.005; // How fast ablation progresses per frame
        const EXCESSIVE_THRESHOLD = 1.5; // Progress level where it becomes excessive
        const ADEQUATE_THRESHOLD = 1.0; // Progress level where it becomes adequate
        const INCOMPLETE_THRESHOLD = 0.1; // Progress level where it becomes incomplete
        const HEAT_SPREAD_RADIUS = 2.5 * voxelSize; // How far heat spreads

        // Voxel states
        const STATE_UNTOUCHED = 'untouched';
        const STATE_INCOMPLETE = 'incomplete';
        const STATE_ADEQUATE = 'adequate';
        const STATE_EXCESSIVE = 'excessive';

        // --- Initialization ---
        function initGame() {
            // Reset state
            gameActive = false;
            rfActive = false;
            score = 0;
            timeLeft = 60;
            power = 50;
            needlePos = { x: ultrasoundCanvas.width / 2, y: 50 }; // Start needle at top center
            voxels = [];
            totalNoduleVoxels = 0;
            warningArea.textContent = '';
            if (timerInterval) clearInterval(timerInterval);
            if (animationFrameId) cancelAnimationFrame(animationFrameId);

            // Setup Nodule (Example: Centered Circle)
            const noduleRadius = 50;
            const noduleCenterX = ultrasoundCanvas.width / 2;
            const noduleCenterY = ultrasoundCanvas.height / 2 + 50; // Position lower half
            nodule = { x: noduleCenterX, y: noduleCenterY, radius: noduleRadius };

            // Create Voxels within the nodule
            const startX = Math.floor((noduleCenterX - noduleRadius) / voxelSize) * voxelSize;
            const startY = Math.floor((noduleCenterY - noduleRadius) / voxelSize) * voxelSize;
            const endX = Math.ceil((noduleCenterX + noduleRadius) / voxelSize) * voxelSize;
            const endY = Math.ceil((noduleCenterY + noduleRadius) / voxelSize) * voxelSize;

            for (let x = startX; x < endX; x += voxelSize) {
                for (let y = startY; y < endY; y += voxelSize) {
                    // Check if voxel center is within the circle
                    const dx = (x + voxelSize / 2) - noduleCenterX;
                    const dy = (y + voxelSize / 2) - noduleCenterY;
                    if (dx * dx + dy * dy <= noduleRadius * noduleRadius) {
                        voxels.push({
                            x: x,
                            y: y,
                            size: voxelSize,
                            state: STATE_UNTOUCHED,
                            ablationProgress: 0 // 0 to EXCESSIVE_THRESHOLD+
                        });
                        totalNoduleVoxels++;
                    }
                }
            }

            // Setup Critical Structures (Simplified on Anatomy Canvas)
            criticalStructures = [
                { x: anatomyCanvas.width * 0.3, y: 20, width: 40, height: 60, name: 'Vessel' },
                { x: anatomyCanvas.width * 0.6, y: 20, width: 50, height: 60, name: 'Trachea' }
            ];

            // Reset UI
            rfButton.textContent = 'RF OFF';
            rfButton.classList.remove('on');
            rfButton.disabled = true; // Disabled until game starts
            resetButton.disabled = true;
            startButton.disabled = false;
            powerSlider.value = power;
            powerValueSpan.textContent = power;
            updateMetrics(); // Initial metrics display
            draw(); // Initial draw
            hideMessage();
        }

        // --- Drawing Functions ---
        function drawUltrasound() {
            usCtx.clearRect(0, 0, ultrasoundCanvas.width, ultrasoundCanvas.height);
            usCtx.strokeStyle = '#4a4a7f'; // Border color
            usCtx.lineWidth = 2;
            usCtx.strokeRect(0, 0, ultrasoundCanvas.width, ultrasoundCanvas.height);


            // Draw Voxels (representing nodule tissue)
            voxels.forEach(voxel => {
                switch (voxel.state) {
                    case STATE_INCOMPLETE: usCtx.fillStyle = 'rgba(231, 76, 60, 0.7)'; break; // Red
                    case STATE_ADEQUATE: usCtx.fillStyle = 'rgba(46, 204, 113, 0.7)'; break; // Green
                    case STATE_EXCESSIVE: usCtx.fillStyle = 'rgba(127, 140, 141, 0.7)'; break; // Gray
                    default: usCtx.fillStyle = 'rgba(149, 165, 166, 0.3)'; break; // Light Gray (Untouched)
                }
                usCtx.fillRect(voxel.x, voxel.y, voxel.size, voxel.size);
                usCtx.strokeStyle = '#333'; // Voxel grid lines
                usCtx.strokeRect(voxel.x, voxel.y, voxel.size, voxel.size);
            });

             // Draw Nodule Outline (optional, for clarity)
            if (nodule) {
                usCtx.strokeStyle = '#3498db'; // Blue outline
                usCtx.lineWidth = 2;
                usCtx.beginPath();
                usCtx.arc(nodule.x, nodule.y, nodule.radius, 0, Math.PI * 2);
                usCtx.stroke();
            }

            // Draw Needle
            usCtx.fillStyle = '#f1c40f'; // Yellow needle tip
            usCtx.beginPath();
            usCtx.arc(needlePos.x, needlePos.y, 5, 0, Math.PI * 2); // Needle tip
            usCtx.fill();
            usCtx.strokeStyle = '#bdc3c7'; // Light gray needle shaft
            usCtx.lineWidth = 2;
            usCtx.beginPath();
            usCtx.moveTo(needlePos.x, 0); // Shaft from top edge
            usCtx.lineTo(needlePos.x, needlePos.y);
            usCtx.stroke();

             // Draw RF effect visualization if active
             if (rfActive) {
                usCtx.fillStyle = 'rgba(255, 255, 0, 0.15)'; // Yellowish glow
                usCtx.beginPath();
                usCtx.arc(needlePos.x, needlePos.y, HEAT_SPREAD_RADIUS, 0, Math.PI * 2);
                usCtx.fill();
            }
        }

        function drawAnatomy() {
            anCtx.clearRect(0, 0, anatomyCanvas.width, anatomyCanvas.height);
            anCtx.strokeStyle = '#4a4a7f'; // Border color
            anCtx.lineWidth = 2;
            anCtx.strokeRect(0, 0, anatomyCanvas.width, anatomyCanvas.height);


            // Draw simplified neck outline (optional)
            anCtx.strokeStyle = '#7f8c8d';
            anCtx.lineWidth = 1;
            anCtx.strokeRect(anatomyCanvas.width * 0.1, 10, anatomyCanvas.width * 0.8, anatomyCanvas.height - 20); // Box representing general area

            // Draw Critical Structures
            criticalStructures.forEach(struct => {
                anCtx.fillStyle = '#c0392b'; // Red for critical structures
                anCtx.fillRect(struct.x, struct.y, struct.width, struct.height);
                anCtx.fillStyle = '#fff';
                anCtx.font = "10px 'Press Start 2P'";
                anCtx.textAlign = 'center';
                anCtx.fillText(struct.name, struct.x + struct.width / 2, struct.y + struct.height / 2 + 5);
            });

            // Draw Needle Position Indicator
            // Map ultrasound X-coord to anatomy X-coord
            const anatomyNeedleX = (needlePos.x / ultrasoundCanvas.width) * (anatomyCanvas.width * 0.8) + (anatomyCanvas.width * 0.1);
            anCtx.fillStyle = '#f1c40f'; // Yellow
            anCtx.fillRect(anatomyNeedleX - 2, 0, 4, anatomyCanvas.height); // Vertical line indicator
        }

        function draw() {
            // Check if the game should stop drawing
            // This condition prevents drawing if the game ended but the animation frame was already requested
             if (!gameActive && !animationFrameId) {
                return; // Stop if game is not active and no frame is pending
            }
             if (!gameActive && timeLeft <=0) {
                 // If game ended due to time or other reasons, ensure we cancel any pending frame
                 if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; // Clear the ID
                 }
                 return; // Stop drawing
             }

            drawUltrasound();
            drawAnatomy();
            // Request the next frame only if the game is active
            if(gameActive) {
                animationFrameId = requestAnimationFrame(draw);
            } else {
                 animationFrameId = null; // Ensure ID is cleared if game becomes inactive
            }
        }

        // --- Game Logic ---
        function updateMetrics() {
            let adequateCount = 0;
            let incompleteCount = 0;
            let excessiveCount = 0;
            let untouchedCount = 0;

            voxels.forEach(voxel => {
                switch (voxel.state) {
                    case STATE_ADEQUATE: adequateCount++; break;
                    case STATE_INCOMPLETE: incompleteCount++; break;
                    case STATE_EXCESSIVE: excessiveCount++; break;
                    default: untouchedCount++; break;
                }
            });

            const calcPercent = (count) => totalNoduleVoxels > 0 ? Math.round((count / totalNoduleVoxels) * 100) : 0;

            const adequateP = calcPercent(adequateCount);
            const incompleteP = calcPercent(incompleteCount);
            const excessiveP = calcPercent(excessiveCount);
            // Ensure percentages sum correctly, especially with rounding
            const untouchedP = Math.max(0, 100 - adequateP - incompleteP - excessiveP);


            adequatePercentSpan.textContent = adequateP;
            incompletePercentSpan.textContent = incompleteP;
            excessivePercentSpan.textContent = excessiveP;
            untouchedPercentSpan.textContent = untouchedP;

            // Simple Scoring: Reward adequate, penalize excessive
             score = adequateP * 10 - excessiveP * 5; // Base score during game
             scoreSpan.textContent = score;

            timerSpan.textContent = timeLeft;
        }

        function applyAblation() {
            if (!rfActive || !gameActive) return;

            let isNearCritical = false; // Track if needle is near critical structure this frame
            let isOutsideTarget = false; // Track if needle is outside target zone this frame
            let warningMsg = '';

            voxels.forEach(voxel => {
                const dx = (voxel.x + voxel.size / 2) - needlePos.x;
                const dy = (voxel.y + voxel.size / 2) - needlePos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < HEAT_SPREAD_RADIUS) {
                    // Increase ablation progress based on power, distance, and time step
                    const heatFactor = Math.max(0, 1 - (distance / HEAT_SPREAD_RADIUS)); // Ensure factor is not negative
                    voxel.ablationProgress += heatFactor * (power / 50) * ABLATION_RATE_FACTOR; // Adjust rate as needed

                    // Update voxel state based on progress
                    if (voxel.ablationProgress >= EXCESSIVE_THRESHOLD) {
                        voxel.state = STATE_EXCESSIVE;
                    } else if (voxel.ablationProgress >= ADEQUATE_THRESHOLD) {
                        voxel.state = STATE_ADEQUATE;
                    } else if (voxel.ablationProgress >= INCOMPLETE_THRESHOLD) {
                        voxel.state = STATE_INCOMPLETE;
                    }
                }
            });

             // --- Complication Checks ---
             // 1. Check proximity to critical structures
             const anatomyNeedleX = (needlePos.x / ultrasoundCanvas.width) * (anatomyCanvas.width * 0.8) + (anatomyCanvas.width * 0.1);
             criticalStructures.forEach(struct => {
                 // Check for overlap
                 if (anatomyNeedleX >= struct.x && anatomyNeedleX <= struct.x + struct.width) {
                     isNearCritical = true;
                     warningMsg = `WARNING: Needle near ${struct.name}!`;
                     // Optional: Apply immediate score penalty or increase risk factor
                     // score -= 1;
                 }
             });

             // 2. Check if needle tip is significantly outside the target nodule
             const distFromNoduleCenter = Math.sqrt(Math.pow(needlePos.x - nodule.x, 2) + Math.pow(needlePos.y - nodule.y, 2));
             // Define a buffer zone around the nodule
             const safeRadius = nodule.radius + HEAT_SPREAD_RADIUS; // Allow ablation effect near edge
             if (distFromNoduleCenter > safeRadius) {
                 isOutsideTarget = true;
                 // Prioritize critical structure warning if both occur
                 if (!isNearCritical) {
                    warningMsg = 'WARNING: Needle outside target zone!';
                 }
                 // Optional: Apply score penalty
                 // score -= 1;
             }

             // Display the most relevant warning
             warningArea.textContent = warningMsg;

             // Potential Game Over condition (Example: sustained complication)
             // Could track consecutive frames with warnings or a total warning count
             // if (isNearCritical || isOutsideTarget) {
             //    complicationCounter++;
             //    if (complicationCounter > 100) { // Example threshold
             //       endGame(false, "Sustained Complication!"); // Pass a specific message
             //    }
             // } else {
             //    complicationCounter = 0; // Reset if no complication this frame
             // }
        }

        // Central game loop run by interval timer
        let gameLogicInterval = null;
        function gameLoop() {
            if (!gameActive) {
                 if (gameLogicInterval) {
                    clearInterval(gameLogicInterval); // Stop interval if game becomes inactive
                    gameLogicInterval = null;
                 }
                return;
            }
            applyAblation();
            updateMetrics();
        }

        function startGame() {
            if (gameActive) return;
            initGame(); // Reset everything first
            gameActive = true;
            startButton.disabled = true;
            resetButton.disabled = false;
            rfButton.disabled = false;

            // Start the timer interval
            timerInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft <= 0) {
                    timeLeft = 0; // Ensure timer doesn't go negative
                    endGame(true); // Time's up
                }
                 updateMetrics(); // Update timer display every second
            }, 1000);

             // Start the game logic loop using setInterval
             if (gameLogicInterval) clearInterval(gameLogicInterval); // Clear any previous interval
             gameLogicInterval = setInterval(gameLoop, 50); // Run game logic updates (e.g., 20 times per second)

            // Start drawing loop using requestAnimationFrame
            if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous frame request
            animationFrameId = requestAnimationFrame(draw); // Start drawing
        }

        function endGame(timeUp = false, endMessage = null) {
             if (!gameActive) return; // Prevent multiple ends

             gameActive = false; // Set game state to inactive *first*
             rfActive = false; // Ensure RF is off

             // Stop intervals and animation frames
             if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
             }
             if (gameLogicInterval) {
                 clearInterval(gameLogicInterval);
                 gameLogicInterval = null;
             }
             if (animationFrameId) {
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }


            // Perform final metric calculation and scoring
            let adequateCount = 0;
            let incompleteCount = 0;
            let excessiveCount = 0;
             voxels.forEach(voxel => {
                switch (voxel.state) {
                    case STATE_ADEQUATE: adequateCount++; break;
                    case STATE_INCOMPLETE: incompleteCount++; break;
                    case STATE_EXCESSIVE: excessiveCount++; break;
                }
            });
             const adequateP = totalNoduleVoxels > 0 ? Math.round((adequateCount / totalNoduleVoxels) * 100) : 0;
             const incompleteP = totalNoduleVoxels > 0 ? Math.round((incompleteCount / totalNoduleVoxels) * 100) : 0;
             const excessiveP = totalNoduleVoxels > 0 ? Math.round((excessiveCount / totalNoduleVoxels) * 100) : 0;

             // Heavier final penalties for incomplete/excessive
             let finalScore = adequateP * 10 - incompleteP * 10 - excessiveP * 15;
             finalScore = Math.max(0, finalScore); // Score cannot be negative
             scoreSpan.textContent = finalScore; // Update display

            // Determine the end message
            let message = endMessage || (timeUp ? "Time's Up!" : "Procedure Complete!"); // Use provided message or default
            message += `\n\nFinal Score: ${finalScore}`;
            message += `\n--------------`;
            message += `\nAdequate: ${adequateP}%`;
            message += `\nIncomplete: ${incompleteP}%`;
            message += `\nExcessive: ${excessiveP}%`;
            showMessage(message);

            // Update UI element states
            rfButton.textContent = 'RF OFF';
            rfButton.classList.remove('on');
            rfButton.disabled = true;
            resetButton.disabled = false; // Allow reset
            startButton.disabled = true; // Keep start disabled until reset
            warningArea.textContent = ''; // Clear any lingering warnings
        }


        function showMessage(msg) {
            messageText.innerText = msg; // Use innerText to handle newlines properly
            messageBox.style.display = 'block';
        }

        function hideMessage() {
            messageBox.style.display = 'none';
        }

        // --- Event Listeners ---
        ultrasoundCanvas.addEventListener('mousemove', (e) => {
            if (!gameActive) return;
            const rect = ultrasoundCanvas.getBoundingClientRect();
            needlePos.x = e.clientX - rect.left;
            needlePos.y = e.clientY - rect.top;

            // Clamp needle position to canvas bounds
            needlePos.x = Math.max(0, Math.min(ultrasoundCanvas.width, needlePos.x));
            needlePos.y = Math.max(0, Math.min(ultrasoundCanvas.height, needlePos.y));
        });

        rfButton.addEventListener('click', () => {
            if (!gameActive) return;
            rfActive = !rfActive;
            rfButton.textContent = rfActive ? 'RF ON' : 'RF OFF';
            rfButton.classList.toggle('on', rfActive);
            if (!rfActive) {
                 warningArea.textContent = ''; // Clear warnings when RF turned off
            }
        });

        powerSlider.addEventListener('input', (e) => {
            power = parseInt(e.target.value);
            powerValueSpan.textContent = power;
        });

        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', initGame); // Reset calls initGame
        closeMessageButton.addEventListener('click', hideMessage);


        // --- Initial Setup ---
        window.onload = initGame; // Initialize when the page loads

    </script>
</body>
</html>
