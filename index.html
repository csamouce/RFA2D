<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nodule Radiofrequency Ablation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Apply the Roboto font */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #e5e7eb; /* Tailwind gray-200 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        /* Style the canvas elements */
        canvas {
            background-color: #111827; /* Tailwind gray-900 */
            border: 2px solid #4b5563; /* Tailwind gray-600 */
            border-radius: 8px;
            display: block;
            max-width: 100%;
        }
        /* Removed structureAnatomyCanvas styles */
         #sliceAnatomyCanvas { /* Canvas for slice view AND entry click trigger */
             cursor: pointer;
         }
        #ultrasoundCanvas {
             cursor: crosshair;
             background-color: #111827; /* Match other canvases */
             border: 2px solid #4b5563; /* Match other canvases */
        }

        /* Style buttons with arcade feel */
        button, .nodule-button {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            background-color: #1d4ed8; /* Tailwind blue-700 */
            color: #ffffff;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px #1e3a8a; /* Tailwind blue-800 */
            cursor: pointer;
            transition: all 0.1s ease;
            margin: 5px;
            text-transform: uppercase;
            font-size: 0.9em;
        }
        button:hover, .nodule-button:hover {
             background-color: #1e40af; /* Darker blue-800 on hover */
        }
        button:active, .nodule-button:active {
            box-shadow: 0 2px #1e3a8a;
            transform: translateY(2px);
        }
        button:disabled, .nodule-button:disabled {
            background-color: #4b5563; /* Tailwind gray-600 */
            box-shadow: 0 4px #374151; /* Tailwind gray-700 */
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* Style the RF ON button specifically (keep red) */
        #rfButton.on {
             background-color: #e74c3c;
             box-shadow: 0 4px #c0392b;
        }
         #rfButton.on:active {
             box-shadow: 0 2px #c0392b;
         }
          #rfButton.on:hover {
             background-color: #c0392b;
         }
         /* Style for selected nodule button (UF Orange) */
         .nodule-button.selected {
            background-color: #f97316; /* Tailwind orange-500 */
            box-shadow: 0 4px #ea580c; /* Tailwind orange-600 */
         }
         .nodule-button.selected:active {
             box-shadow: 0 2px #ea580c;
         }
         .nodule-button.selected:hover {
             background-color: #ea580c;
         }
         /* Style for info/toggle buttons */
         #toggleObscuringButton, #toggleGridButton {
             font-size: 0.8em;
             padding: 5px 10px;
             background-color: #1d4ed8; /* Tailwind blue-700 */
             box-shadow: 0 4px #1e3a8a; /* Tailwind blue-800 */
         }
          #toggleObscuringButton:active, #toggleGridButton:active {
             box-shadow: 0 2px #1e3a8a;
         }
          #toggleObscuringButton:hover, #toggleGridButton:hover {
              background-color: #1e40af; /* Darker blue-800 */
          }
          /* Style for Remove Needle button */
          #removeNeedleButton {
             font-size: 0.75rem; /* Slightly smaller */
             padding: 2px 8px; /* Smaller padding */
             background-color: #dc2626; /* Tailwind red-600 */
             box-shadow: 0 3px #b91c1c; /* Tailwind red-700 */
             margin-top: 1px; /* Space from warning text */
             pointer-events: auto; /* Make sure it's clickable */
          }
           #removeNeedleButton:hover {
             background-color: #b91c1c; /* Darker red */
           }
            #removeNeedleButton:active {
             box-shadow: 0 1px #b91c1c;
             transform: translateY(1px);
            }


        /* Style the message box */
        #messageBox {
            font-family: 'Roboto', sans-serif;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(31, 41, 55, 0.95); /* Tailwind gray-800 */
            color: #f0f9ff;
            padding: 30px;
            border: 3px solid #60a5fa; /* Tailwind blue-400 */
            border-radius: 10px;
            text-align: left;
            z-index: 100;
            display: none;
            font-size: 1.0em;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
            white-space: pre-wrap;
            max-width: 90%;
            width: 600px;
            line-height: 1.6;
        }
         #messageBox h3 {
            font-size: 1.4em;
            font-weight: 700;
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
         }
         #messageBox p {
             font-size: 1.0em;
             color: #d1d5db;
             margin-bottom: 10px;
         }
         #messageBox button { /* Use accent blue for OK button */
             display: block;
             margin: 20px auto 0 auto;
             background-color: #1d4ed8; /* blue-700 */
             box-shadow: 0 4px #1e3a8a; /* blue-800 */
         }
          #messageBox button:hover {
             background-color: #1e40af; /* blue-800 */
          }


        /* Style for different ablation states (functional colors unchanged) */
        .status-untouched { color: #95a5a6; }
        .status-incomplete { color: #e74c3c; }
        .status-adequate { color: #2ecc71; }
        .status-excessive { color: #7f8c8d; }
        .warning { color: #f97316; font-weight: bold; } /* UF Orange */
        .instruction { color: #60a5fa; font-size: 1.0em; min-height: 1.2em; } /* Lighter Blue */

        /* Container for the game */
        .game-container {
            background-color: #374151; /* Tailwind gray-700 */
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            max-width: 95%;
            width: 1200px;
        }
        /* Inner panel backgrounds */
        .panel {
             background-color: #1f2937; /* Tailwind gray-800 */
             padding: 0.5rem; /* p-2 */
             border-radius: 0.5rem; /* rounded */
             box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); /* shadow */
             position: relative; /* Needed for absolute positioning of warning area */
        }
         .panel-lg { /* Larger padding for controls panel */
             background-color: #1f2937; /* Tailwind gray-800 */
             padding: 1rem; /* p-4 */
             border-radius: 0.5rem; /* rounded */
             box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06); /* shadow */
        }

        /* Ensure range input looks consistent */
        input[type=range] {
            height: 10px;
            cursor: pointer;
            background: #4b5563; /* Tailwind gray-600 */
            border-radius: 5px;
            appearance: none;
            -webkit-appearance: none;
        }
        /* Style range thumbs */
        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            -webkit-appearance: none;
            height: 20px;
            width: 10px;
            background: #1d4ed8; /* UF Blue */
            border-radius: 3px;
        }
        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 10px;
            background: #1d4ed8; /* UF Blue */
            border-radius: 3px;
            border: none;
        }
        /* General text size adjustment */
        .text-xs { font-size: 0.8rem; line-height: 1.1rem; }
        .text-sm { font-size: 0.9rem; line-height: 1.25rem; }
        .text-md { font-size: 1.1rem; line-height: 1.6rem; }
        .text-lg { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.75rem; line-height: 2.1rem; }

        /* Specific Text Color Overrides */
        .heading-color { color: #f3f4f6; } /* Tailwind gray-100 */
        .subheading-color { color: #d1d5db; } /* Tailwind gray-300 */
        .label-color { color: #e5e7eb; } /* Tailwind gray-200 */


    </style>
</head>
<body>
    <div class="game-container w-full max-w-5xl mx-auto p-4 rounded-lg shadow-lg bg-gray-700">
        <h1 class="text-2xl text-center mb-4 text-white font-bold">Nodule Radiofrequency Ablation</h1>

        <div class="flex flex-wrap justify-center items-center gap-4 mb-6 p-4 bg-gray-800 rounded shadow">
             <div class="text-center">
                 <h3 class="text-md mb-2 subheading-color">Select Nodule Size</h3>
                 <div id="noduleSelection" class="flex justify-center flex-wrap">
                      <button class="nodule-button" data-size="75">3 cm</button>
                      <button class="nodule-button" data-size="100">4 cm</button>
                      <button class="nodule-button" data-size="125">5 cm</button>
                 </div>
             </div>
             <div class="text-center">
                  <button id="startButton" disabled>Start</button>
                  <button id="resetButton" disabled>Reset</button>
                  </div>
        </div>

        <p id="instructionText" class="text-center instruction mb-2">Select Nodule Size Above</p>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-4">

            <div class="lg:col-span-2 space-y-4">
                <div class="panel relative">
                    <h2 class="text-lg text-center mb-2 heading-color">Ultrasound View</h2>
                    <canvas id="ultrasoundCanvas" width="600" height="400"></canvas>
                    <div class="absolute bottom-2 left-0 right-0 text-center pointer-events-none h-10 flex flex-col items-center">
                        <span id="warningTextSpan" class="text-orange-500 font-bold text-sm"></span>
                        <button id="removeNeedleButton" class="mt-1 px-2 py-1 text-xs bg-red-600 hover:bg-red-700 text-white rounded shadow pointer-events-auto hidden">&nbsp;Remove Needle&nbsp;</button>
                    </div>
                </div>
                 <div class="panel">
                    <h2 class="text-lg text-center mb-2 heading-color">Top-Down View</h2>
                    <canvas id="sliceAnatomyCanvas" width="750" height="100"></canvas>
                 </div>
            </div>

            <div class="lg:col-span-1 panel-lg flex flex-col"> <div>
                    <h2 class="text-lg text-center mb-3 heading-color">Controls & Metrics</h2>

                    <div class="text-center mb-4">
                        <h3 class="text-md mb-2 subheading-color">RF Generator</h3>
                        <div class="flex justify-center items-center gap-2 mb-1">
                            <button id="rfButton" disabled>RF OFF</button>
                            <button id="toggleObscuringButton" title="Toggle Ultrasound Shadowing Effect">SHADOWING ON</button>
                            <button id="toggleGridButton" title="Toggle Grid/Outline Visibility">GRID ON</button>
                        </div>
                        <p class="text-xs mt-1">(Spacebar to toggle RF)</p>
                        <p class="text-xs mt-1">(Arrow Up/Down for slice)</p>
                        <div class="mt-2">
                            <label for="powerSlider" class="block text-sm mb-1 label-color">Power: <span id="powerValue">50</span>W</label>
                            <input type="range" id="powerSlider" min="10" max="100" value="50" step="5" class="w-full">
                        </div>
                    </div>

                    <div class="text-sm space-y-1">
                        <h3 class="text-md mb-2 subheading-color">Ablation Status</h3>
                        <p class="label-color">Tip Temp: <span id="temperatureValue" class="font-bold text-white">--</span> Â°C</p>
                        <p class="label-color">Slice: <span id="depthValue" class="font-bold text-white">-- / --</span></p>
                        <hr class="my-2 border-gray-600">
                        <p class="label-color">Adequate: <span id="adequatePercent" class="status-adequate font-bold">0</span>%</p>
                        <p class="label-color">Incomplete: <span id="incompletePercent" class="status-incomplete font-bold">0</span>%</p>
                        <p class="label-color">Excessive: <span id="excessivePercent" class="status-excessive font-bold">0</span>%</p>
                        <p class="label-color">Untouched: <span id="untouchedPercent" class="status-untouched font-bold">100</span>%</p>
                        </div>
                </div>
            </div>
        </div>

         <div id="messageBox">
            <p id="messageText"></p>
            <button id="closeMessageButton" class="mt-4">OK</button>
        </div>
    </div>

    <script>
        // --- Canvas Setup ---
        const ultrasoundCanvas = document.getElementById('ultrasoundCanvas');
        const usCtx = ultrasoundCanvas.getContext('2d');
        // const structureAnatomyCanvas = document.getElementById('structureAnatomyCanvas'); // Removed
        // const structureAnCtx = structureAnatomyCanvas.getContext('2d'); // Removed
        const sliceAnatomyCanvas = document.getElementById('sliceAnatomyCanvas');
        const sliceAnCtx = sliceAnatomyCanvas.getContext('2d');

        // --- Game Elements ---
        const rfButton = document.getElementById('rfButton');
        const powerSlider = document.getElementById('powerSlider');
        const powerValueSpan = document.getElementById('powerValue');
        const temperatureValueSpan = document.getElementById('temperatureValue');
        const depthValueSpan = document.getElementById('depthValue');
        const adequatePercentSpan = document.getElementById('adequatePercent');
        const incompletePercentSpan = document.getElementById('incompletePercent');
        const excessivePercentSpan = document.getElementById('excessivePercent');
        const untouchedPercentSpan = document.getElementById('untouchedPercent');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        // const ultrasoundWarningArea = document.getElementById('ultrasoundWarningArea'); // Div container
        const warningTextSpan = document.getElementById('warningTextSpan'); // Span for text
        const removeNeedleButton = document.getElementById('removeNeedleButton'); // Button for reset
        const instructionText = document.getElementById('instructionText');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessageButton = document.getElementById('closeMessageButton');
        const noduleSelectionDiv = document.getElementById('noduleSelection');
        const noduleButtons = noduleSelectionDiv.querySelectorAll('.nodule-button');
        const toggleObscuringButton = document.getElementById('toggleObscuringButton');
        const toggleGridButton = document.getElementById('toggleGridButton');

        // --- Game State Variables ---
        let gameActive = false;
        let rfActive = false;
        let animationFrameId = null;
        let power = 50;
        let needleState = 'idle';
        let entryPoint = null;
        let pivotPoint = null;
        let needlePos = { x: 0, y: 0 };
        let needleAngle = Math.PI / 2;
        let initialInsertionAngle = null;
        const MAX_ANGLE_LIMIT = Math.PI / 36;
        const MIN_ANGLE_LIMIT = Math.PI / 180;
        const MAX_DEPTH_FOR_LIMIT_CHANGE = ultrasoundCanvas.height * 0.75;
        let needleLength = 100;
        const retractionThreshold = 15;
        let nodule = null;
        let nearbyStructures = []; // Holds definitions for Carotid, IJV, Trachea
        let voxels = [];
        let voxelMap = new Map();
        const voxelSize = 10;
        let totalNoduleVoxels = 0;
        let selectedNoduleRadius = null;
        let currentSlice = 0;
        let maxSlices = 5;
        let obscuringEffectActive = true;
        let showGridAndOutline = true;
        let noiseCanvas = null;
        let isNeedleOnTargetVertically = false; // Flag for Y-axis entry check

        // Ablation constants
        const ABLATION_RATE_FACTOR = 0;
        const EXCESSIVE_THRESHOLD = 1.5;
        const ADEQUATE_THRESHOLD = 1.0;
        const INCOMPLETE_THRESHOLD = 0.1;
        const BASE_HEAT_SPREAD_RADIUS = voxelSize * 4.0;
        const TIP_CONDITION_RADIUS = voxelSize * 1.5;
        const THERMAL_DIFFUSIVITY = 0.025;
        const PIXELS_PER_CM = 50;
        const ACTIVE_ELECTRODE_LENGTH = PIXELS_PER_CM;

        // Temp constants
        const BODY_TEMP = 37.0;
        const MAX_TEMP = 100.0;
        const EFFECTIVE_TEMP_THRESHOLD = 60.0;
        const TEMP_INCREASE_RATE = 0.35;
        const TEMP_DECREASE_RATE = 0.005;

        // Voxel states & Colors
        const STATE_UNTOUCHED = 'untouched';
        const STATE_INCOMPLETE = 'incomplete';
        const STATE_ADEQUATE = 'adequate';
        const STATE_EXCESSIVE = 'excessive';
        const COLOR_UNTOUCHED = { r: 149, g: 165, b: 166, a: 0.3 };
        const COLOR_INCOMPLETE = { r: 231, g: 76, b: 60, a: 0.7 };
        const COLOR_ADEQUATE = { r: 46, g: 204, b: 113, a: 0.7 };
        const COLOR_EXCESSIVE = { r: 127, g: 140, b: 141, a: 0.7 };
        const COLOR_OBSCURED = { r: 50, g: 50, b: 60, a: 0.8 };

        // --- Initialization ---
        function initGame(isReset = false) {
            gameActive = false; rfActive = false; /* score = 0; */
            needleState = 'idle'; entryPoint = null; pivotPoint = null; initialInsertionAngle = null;
            needleAngle = Math.PI / 2; needleLength = 100; needlePos = { x: -100, y: -100 };
            voxels = []; totalNoduleVoxels = 0; nodule = null; voxelMap.clear(); nearbyStructures = [];
            warningTextSpan.textContent = ''; // Clear warning text
            removeNeedleButton.classList.add('hidden'); // Hide button
            instructionText.textContent = 'Select Nodule Size Above';
            isNeedleOnTargetVertically = false; // Reset flag
            if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
            if (gameLogicInterval) clearInterval(gameLogicInterval); gameLogicInterval = null;

             if (selectedNoduleRadius && !isReset) { createNoduleAndVoxels(); instructionText.textContent = 'Click Start'; startButton.disabled = false; }
             else if (!isReset) { startButton.disabled = true; }

            // criticalStructures removed
            rfButton.textContent = 'RF OFF'; rfButton.classList.remove('on'); rfButton.disabled = true;
            powerSlider.disabled = false;
            resetButton.disabled = true; powerSlider.value = power; powerValueSpan.textContent = power;
            noduleButtons.forEach(btn => btn.disabled = false);
            if (!isReset || selectedNoduleRadius === null) {
                 noduleButtons.forEach(btn => btn.classList.remove('selected'));
                 selectedNoduleRadius = null;
                 startButton.disabled = true;
            }
            temperatureValueSpan.textContent = '--'; depthValueSpan.textContent = '-- / --';
            adequatePercentSpan.textContent = '0'; incompletePercentSpan.textContent = '0'; excessivePercentSpan.textContent = '0'; untouchedPercentSpan.textContent = '100';
            obscuringEffectActive = true;
            toggleObscuringButton.textContent = 'SHADOWING ON';
            showGridAndOutline = true;
            toggleGridButton.textContent = 'GRID ON';

            if (!noiseCanvas) { generateNoiseBackground(); }

            updateMetrics(); draw(); hideMessage();
        }

        function generateNoiseBackground() { // Unchanged
            noiseCanvas = document.createElement('canvas'); noiseCanvas.width = ultrasoundCanvas.width; noiseCanvas.height = ultrasoundCanvas.height; const noiseCtx = noiseCanvas.getContext('2d'); const gradient = noiseCtx.createLinearGradient(0, 0, 0, noiseCanvas.height); gradient.addColorStop(0, '#252a38'); gradient.addColorStop(1, '#080a10'); noiseCtx.fillStyle = gradient; noiseCtx.fillRect(0, 0, noiseCanvas.width, noiseCanvas.height); const imageData = noiseCtx.getImageData(0, 0, noiseCanvas.width, noiseCanvas.height); const data = imageData.data; const noiseIntensity = 25; for (let i = 0; i < data.length; i += 4) { const baseR = data[i]; const baseG = data[i+1]; const baseB = data[i+2]; const randomNoise = (Math.random() - 0.5) * noiseIntensity; const r = Math.max(0, Math.min(255, baseR + randomNoise)); const g = Math.max(0, Math.min(255, baseG + randomNoise)); const b = Math.max(0, Math.min(255, baseB + randomNoise)); data[i] = r; data[i+1] = g; data[i+2] = b; } noiseCtx.putImageData(imageData, 0, 0);
        }

        function createNoduleAndVoxels() { // Updated nearby structure definitions
             if (!selectedNoduleRadius) return;
             const effectiveRadius = selectedNoduleRadius;
             const noduleCenterX = ultrasoundCanvas.width / 2;
             let baseCenterY = Math.max(effectiveRadius + 20, Math.min(ultrasoundCanvas.height - effectiveRadius - 20, ultrasoundCanvas.height / 1.8));
             let noduleCenterY = baseCenterY + (0.5 * PIXELS_PER_CM);
             noduleCenterY = Math.max(effectiveRadius + 10, noduleCenterY);
             noduleCenterY = Math.min(ultrasoundCanvas.height - effectiveRadius - 10, noduleCenterY);
             nodule = { x: noduleCenterX, y: noduleCenterY, radius: effectiveRadius };

             // Define nearby structures relative to nodule center (in logical ultrasound coordinates)
             // Updated size (x2), position (2cm higher, 1.5cm further away + 0.5cm separation)
             const structureYOffset = -100; // 2cm higher
             const structureXOffset = 75; // 1.5cm further horizontally (base offset)
             const additionalSeparation = 25; // 0.5cm more separation for IJV

             nearbyStructures = [
                 { name: "Carotid Artery", type: 'circle',
                   cx: nodule.x + nodule.radius + structureXOffset, // R + 1.5cm
                   cy: nodule.y + 0 + structureYOffset, // 2cm higher
                   radius: 20, // Doubled size
                   color: 'rgba(180, 0, 0, 0.7)' }, // Color for slice view
                 { name: "Jugular Vein", type: 'circle',
                   cx: nodule.x + nodule.radius + structureXOffset + 30 + additionalSeparation, // R + 1.5cm + 30px + 0.5cm sep
                   cy: nodule.y + 15 + structureYOffset, // 2cm higher
                   radius: 24, // Doubled size
                   color: 'rgba(0, 0, 180, 0.7)' }, // Color for slice view
                 { name: "Trachea", type: 'rect',
                   cx: nodule.x - nodule.radius - structureXOffset - 25, // NoduleX - R - 1.5cm - 25px
                   cy: nodule.y + 0 + structureYOffset + 50, // 2cm higher, +50 to keep center Y roughly same
                   width: 80, // Doubled size
                   height: 100, // Doubled size
                   color: 'rgba(100, 100, 100, 0.6)' } // Color for slice view
             ];


             maxSlices = Math.max(3, Math.ceil(effectiveRadius / (voxelSize * 2)));
             currentSlice = Math.floor(maxSlices / 2);
             voxels = []; totalNoduleVoxels = 0; voxelMap.clear();
             for (let z = 0; z < maxSlices; z++) {
                 const sliceRatio = 1 - Math.abs(z - currentSlice) / (maxSlices / 2); const sliceRadius = effectiveRadius * Math.sqrt(Math.max(0, sliceRatio));
                 const startX = Math.floor((noduleCenterX - sliceRadius) / voxelSize) * voxelSize; const startY = Math.floor((noduleCenterY - sliceRadius) / voxelSize) * voxelSize;
                 const endX = Math.ceil((noduleCenterX + sliceRadius) / voxelSize) * voxelSize; const endY = Math.ceil((noduleCenterY + sliceRadius) / voxelSize) * voxelSize;
                 for (let x = startX; x < endX; x += voxelSize) {
                     for (let y = startY; y < endY; y += voxelSize) {
                         const dx = (x + voxelSize / 2) - noduleCenterX; const dy = (y + voxelSize / 2) - noduleCenterY;
                         if (dx * dx + dy * dy <= sliceRadius * sliceRadius) {
                             const voxel = { x: x, y: y, z: z, size: voxelSize, state: STATE_UNTOUCHED, ablationProgress: 0, temperature: BODY_TEMP, prevTemperature: BODY_TEMP };
                             voxels.push(voxel); voxelMap.set(`${x},${y},${z}`, voxel); totalNoduleVoxels++;
                         }
                     }
                 }
             }
             updateMetrics(); draw();
        }

        // --- Helper Functions --- (Unchanged)
        function getVoxelKey(x, y, z) { return `${x},${y},${z}`; }
        function getNeighbors(voxel) {
            const neighbors = []; const x = voxel.x, y = voxel.y, z = voxel.z;
            const neighborCoords = [ { dx: -voxelSize, dy: 0, dz: 0 }, { dx: voxelSize, dy: 0, dz: 0 }, { dx: 0, dy: -voxelSize, dz: 0 }, { dx: 0, dy: voxelSize, dz: 0 }, { dx: 0, dy: 0, dz: -1 }, { dx: 0, dy: 0, dz: 1 } ];
            neighborCoords.forEach(offset => { const neighbor = voxelMap.get(getVoxelKey(x + offset.dx, y + offset.dy, z + offset.dz)); if (neighbor) neighbors.push(neighbor); });
            return neighbors;
        }
        function calculateTipConditions() {
            if (needleState !== 'inserted') return { temperature: BODY_TEMP };
            let tempSum = 0, nearbyVoxelsCount = 0;
            voxels.filter(v => v.z === currentSlice).forEach(voxel => { const dx = (voxel.x + voxel.size / 2) - needlePos.x; const dy = (voxel.y + voxel.size / 2) - needlePos.y; if (Math.sqrt(dx * dx + dy * dy) < TIP_CONDITION_RADIUS) { tempSum += voxel.temperature; nearbyVoxelsCount++; } });
            const avgTemp = nearbyVoxelsCount > 0 ? tempSum / nearbyVoxelsCount : BODY_TEMP;
            return { temperature: avgTemp };
        }
        function lerp(start, end, t) {
            return start + t * (end - start);
        }
        function getInterpolatedIncompleteColor(temperature) {
            const tempRange = EFFECTIVE_TEMP_THRESHOLD - BODY_TEMP;
            if (tempRange <= 0) return `rgba(${COLOR_UNTOUCHED.r}, ${COLOR_UNTOUCHED.g}, ${COLOR_UNTOUCHED.b}, ${COLOR_UNTOUCHED.a})`;
            let t = (temperature - BODY_TEMP) / tempRange; t = Math.max(0, Math.min(1, t));
            const r = Math.round(lerp(COLOR_UNTOUCHED.r, COLOR_INCOMPLETE.r, t)); const g = Math.round(lerp(COLOR_UNTOUCHED.g, COLOR_INCOMPLETE.g, t)); const b = Math.round(lerp(COLOR_UNTOUCHED.b, COLOR_INCOMPLETE.b, t)); const a = lerp(COLOR_UNTOUCHED.a, COLOR_INCOMPLETE.a, t);
            return `rgba(${r}, ${g}, ${b}, ${a.toFixed(2)})`;
        }
        function distancePointToLineSegment3D(point, p1, p2) {
            const v = { x: p2.x - p1.x, y: p2.y - p1.y, z: p2.z - p1.z }; const w = { x: point.x - p1.x, y: point.y - p1.y, z: point.z - p1.z };
            const c1 = w.x * v.x + w.y * v.y + w.z * v.z; if (c1 <= 0) { return Math.sqrt(w.x * w.x + w.y * w.y + w.z * w.z); }
            const c2 = v.x * v.x + v.y * v.y + v.z * v.z; if (c2 <= c1) { const w2 = { x: point.x - p2.x, y: point.y - p2.y, z: point.z - p2.z }; return Math.sqrt(w2.x * w2.x + w2.y * w2.y + w2.z * w2.z); }
            const b = c1 / c2; const pb = { x: p1.x + b * v.x, y: p1.y + b * v.y, z: p1.z + b * v.z }; const distVec = { x: point.x - pb.x, y: point.y - pb.y, z: point.z - pb.z }; return Math.sqrt(distVec.x * distVec.x + distVec.y * distVec.y + distVec.z * distVec.z);
        }


        // --- Drawing Functions ---
        function drawUltrasound() { // Updated structure colors and preview needle logic
            usCtx.clearRect(0, 0, ultrasoundCanvas.width, ultrasoundCanvas.height); if (noiseCanvas) { usCtx.drawImage(noiseCanvas, 0, 0); } else { usCtx.fillStyle = '#050810'; usCtx.fillRect(0, 0, ultrasoundCanvas.width, ultrasoundCanvas.height); }
            const drawWidth = ultrasoundCanvas.width - 35; usCtx.strokeStyle = '#687088'; usCtx.lineWidth = 2; usCtx.strokeRect(0, 0, drawWidth, ultrasoundCanvas.height);

            // Draw Nearby Structures (behind nodule/voxels)
            if (nodule) {
                nearbyStructures.forEach(struct => {
                    // Use dark gray for vessels in US view, keep defined color for trachea
                    usCtx.fillStyle = (struct.name.includes("Artery") || struct.name.includes("Vein"))
                                        ? 'rgba(60, 60, 70, 0.6)' // Dark gray for vessels
                                        : struct.color; // Original color for trachea
                    if (struct.type === 'circle') {
                        usCtx.beginPath(); usCtx.arc(struct.cx, struct.cy, struct.radius, 0, Math.PI * 2); usCtx.fill();
                    } else if (struct.type === 'rect') {
                        // Draw Trachea as custom shape extending left/bottom with semicircle top
                        if (struct.name === 'Trachea') {
                            const leftEdge = 0;
                            const bottomEdge = ultrasoundCanvas.height;
                            const rightEdge = Math.min(drawWidth, struct.cx + struct.width / 2);
                            const topEdgeY = Math.max(0, struct.cy - struct.height / 2);
                            const semicircleCenterX = (leftEdge + rightEdge) / 2;
                            const semicircleCenterY = topEdgeY;
                            const semicircleRadius = (rightEdge - leftEdge) / 2;

                            usCtx.beginPath();
                            usCtx.moveTo(leftEdge, bottomEdge);
                            usCtx.lineTo(leftEdge, semicircleCenterY);
                            if (semicircleRadius > 0) { // Avoid drawing arc with zero radius
                                usCtx.arc(semicircleCenterX, semicircleCenterY, semicircleRadius, Math.PI, 0, false);
                            } else { // If radius is zero or less, just draw a line across
                                usCtx.lineTo(rightEdge, semicircleCenterY);
                            }
                            usCtx.lineTo(rightEdge, bottomEdge);
                            usCtx.closePath();
                            usCtx.fill();
                        } else { // Fallback for any other potential future rects
                             usCtx.fillRect(struct.cx - struct.width / 2, struct.cy - struct.height / 2, struct.width, struct.height);
                        }
                    }
                });
            }

            // Draw Nodule Voxels & Outline
            if (nodule) { const columns = new Map(); voxels.filter(voxel => voxel.z === currentSlice && voxel.x < drawWidth).forEach(voxel => { if (!columns.has(voxel.x)) { columns.set(voxel.x, []); } columns.get(voxel.x).push(voxel); }); columns.forEach(columnVoxels => { columnVoxels.sort((a, b) => a.y - b.y); let columnObscured = false; columnVoxels.forEach(voxel => { let fillStyle = ''; if (obscuringEffectActive && columnObscured) { fillStyle = `rgba(${COLOR_OBSCURED.r}, ${COLOR_OBSCURED.g}, ${COLOR_OBSCURED.b}, ${COLOR_OBSCURED.a})`; } else { switch (voxel.state) { case STATE_INCOMPLETE: fillStyle = getInterpolatedIncompleteColor(voxel.temperature); break; case STATE_ADEQUATE: fillStyle = `rgba(${COLOR_ADEQUATE.r}, ${COLOR_ADEQUATE.g}, ${COLOR_ADEQUATE.b}, ${COLOR_ADEQUATE.a})`; break; case STATE_EXCESSIVE: fillStyle = `rgba(${COLOR_EXCESSIVE.r}, ${COLOR_EXCESSIVE.g}, ${COLOR_EXCESSIVE.b}, ${COLOR_EXCESSIVE.a})`; break; default: fillStyle = `rgba(${COLOR_UNTOUCHED.r}, ${COLOR_UNTOUCHED.g}, ${COLOR_UNTOUCHED.b}, ${COLOR_UNTOUCHED.a})`; break; } } usCtx.fillStyle = fillStyle; usCtx.fillRect(voxel.x, voxel.y, voxel.size, voxel.size); if (showGridAndOutline) { usCtx.strokeStyle = '#333'; usCtx.lineWidth = 1; usCtx.strokeRect(voxel.x, voxel.y, voxel.size, voxel.size); } if (obscuringEffectActive && !columnObscured && (voxel.state === STATE_ADEQUATE || voxel.state === STATE_EXCESSIVE)) { columnObscured = true; } }); }); if (showGridAndOutline) {const sliceRatio = 1 - Math.abs(currentSlice - Math.floor(maxSlices / 2)) / (maxSlices / 2); const sliceRadius = nodule.radius * Math.sqrt(Math.max(0, sliceRatio)); if (sliceRadius > 0) { usCtx.strokeStyle = '#3498db'; usCtx.lineWidth = 1; usCtx.setLineDash([5, 5]); usCtx.beginPath(); usCtx.arc(nodule.x, nodule.y, sliceRadius, 0, Math.PI * 2); usCtx.stroke(); usCtx.setLineDash([]); } } }

            // Draw Needle only if vertically on target
            if (needleState === 'inserted' && pivotPoint && isNeedleOnTargetVertically) {
                const drawPivotX = Math.min(pivotPoint.x, drawWidth - 1); const baseNeedleX = needlePos.x - Math.cos(needleAngle) * ACTIVE_ELECTRODE_LENGTH; const baseNeedleY = needlePos.y - Math.sin(needleAngle) * ACTIVE_ELECTRODE_LENGTH; usCtx.strokeStyle = '#bdc3c7'; usCtx.lineWidth = 2; usCtx.beginPath(); usCtx.moveTo(drawPivotX, pivotPoint.y); usCtx.lineTo(baseNeedleX, baseNeedleY); usCtx.stroke(); if (rfActive) { usCtx.strokeStyle = '#f1c40f'; usCtx.lineWidth = 4; } else { usCtx.strokeStyle = '#bdc3c7'; usCtx.lineWidth = 2; } usCtx.beginPath(); usCtx.moveTo(baseNeedleX, baseNeedleY); usCtx.lineTo(needlePos.x, needlePos.y); usCtx.stroke(); usCtx.lineWidth = 1;
            }
            // Draw preview needle only if vertically on target
            else if (needleState === 'awaiting_insertion_angle' && pivotPoint && isNeedleOnTargetVertically) { // Keep vertical check
                 const drawPivotX = Math.min(pivotPoint.x, drawWidth - 1); usCtx.strokeStyle = 'rgba(189, 195, 199, 0.5)'; usCtx.lineWidth = 2; usCtx.beginPath(); usCtx.moveTo(drawPivotX, pivotPoint.y); usCtx.lineTo(drawPivotX, pivotPoint.y + 50); usCtx.stroke();
            }
            else if (needleState === 'awaiting_entry_point') { usCtx.fillStyle = '#555'; usCtx.font = "16px 'Roboto'"; usCtx.textAlign = 'center'; usCtx.fillText("Click Nodule Slice View", drawWidth / 2, ultrasoundCanvas.height / 2); }

            // Draw Scale
            const scaleStartX = drawWidth + 5; const scaleStartY = 0; const scaleEndY = ultrasoundCanvas.height - 10; const maxLabelY = scaleStartY + 7 * PIXELS_PER_CM; usCtx.strokeStyle = '#e0e0e0'; usCtx.lineWidth = 1; usCtx.fillStyle = '#e0e0e0'; usCtx.font = "10px 'Roboto'"; usCtx.textAlign = 'right'; usCtx.textBaseline = 'top'; usCtx.beginPath(); usCtx.moveTo(scaleStartX, scaleStartY); usCtx.lineTo(scaleStartX, scaleEndY); usCtx.stroke(); for (let y = scaleStartY; y <= Math.min(scaleEndY, maxLabelY) ; y += PIXELS_PER_CM) { const cmValue = Math.round(y / PIXELS_PER_CM); usCtx.beginPath(); usCtx.moveTo(scaleStartX - 5, y); usCtx.lineTo(scaleStartX + 5, y); usCtx.stroke(); usCtx.fillText(`${cmValue} cm`, scaleStartX - 8, y); } for (let y = maxLabelY + PIXELS_PER_CM; y <= scaleEndY; y += PIXELS_PER_CM) { usCtx.beginPath(); usCtx.moveTo(scaleStartX - 3, y); usCtx.lineTo(scaleStartX + 3, y); usCtx.stroke(); }
        }

        function drawSliceAnatomy() { // Updated labels and structure drawing
            sliceAnCtx.clearRect(0, 0, sliceAnatomyCanvas.width, sliceAnatomyCanvas.height);
            sliceAnCtx.strokeStyle = '#4b5563'; // Match border color
            sliceAnCtx.lineWidth = 2;
            sliceAnCtx.strokeRect(0, 0, sliceAnatomyCanvas.width, sliceAnatomyCanvas.height);
            sliceAnCtx.fillStyle = '#FFFFFF'; // White for labels
            sliceAnCtx.font = "10px 'Roboto'";

            if (nodule) {
                const viewCenterX = sliceAnatomyCanvas.width / 2;
                const viewCenterY = sliceAnatomyCanvas.height / 2;
                const maxDrawRadius = sliceAnatomyCanvas.height / 2 - 10; // Padding for labels
                const maxPossibleNoduleRadius = 125;
                const radiusScaleFactor = maxDrawRadius / maxPossibleNoduleRadius;
                const mainDrawRadius = selectedNoduleRadius * radiusScaleFactor; // Scale current nodule size

                // Draw Nearby Structures as abstract rectangles
                 const structureHeight = sliceAnatomyCanvas.height * 0.8; // Taller
                 nearbyStructures.forEach((struct) => {
                     sliceAnCtx.fillStyle = struct.color; // Use color defined in structure data
                     // Map logical X coord to slice view X coord
                     const drawX = (struct.cx / ultrasoundCanvas.width) * sliceAnatomyCanvas.width;
                     let structureWidth = (struct.type === 'circle' ? struct.radius * 2 : struct.width) * 0.6; // Scaled width

                     // Draw rect centered horizontally at drawX
                     sliceAnCtx.fillRect(drawX - structureWidth / 2, viewCenterY - structureHeight / 2, structureWidth, structureHeight);

                     // Add labels above structures
                     sliceAnCtx.fillStyle = '#FFFFFF'; // White text
                     sliceAnCtx.textAlign = 'center';
                     sliceAnCtx.textBaseline = 'bottom'; // Position label above
                     let labelText = struct.name;
                     if(struct.name === "Carotid Artery") labelText = "Carotid";
                     if(struct.name === "Jugular Vein") labelText = "IJV";
                     sliceAnCtx.fillText(labelText, drawX, viewCenterY - structureHeight / 2 - 3);
                 });

                // Draw the main nodule circle outline (on top of structures)
                sliceAnCtx.strokeStyle = '#7f8c8d';
                sliceAnCtx.lineWidth = 1;
                sliceAnCtx.beginPath();
                sliceAnCtx.arc(viewCenterX, viewCenterY, mainDrawRadius, 0, Math.PI * 2);
                sliceAnCtx.stroke();
                // Label Nodule
                sliceAnCtx.fillStyle = '#FFFFFF'; // White text
                sliceAnCtx.textAlign = 'center';
                sliceAnCtx.textBaseline = 'middle';
                sliceAnCtx.fillText("Nodule", viewCenterX, viewCenterY);


                // Draw the red line representing the current slice's depth
                const redLineWidth = sliceAnatomyCanvas.width * 0.9; // Fixed width
                let lineY = viewCenterY; // Default for 1 slice case
                if (maxSlices > 1) {
                    const relativeDepth = (currentSlice - (maxSlices - 1) / 2) / (maxSlices / 2);
                    lineY = viewCenterY + relativeDepth * mainDrawRadius;
                }
                sliceAnCtx.strokeStyle = '#e74c3c'; // Red line
                sliceAnCtx.lineWidth = 2;
                sliceAnCtx.beginPath();
                sliceAnCtx.moveTo(viewCenterX - redLineWidth / 2, lineY);
                sliceAnCtx.lineTo(viewCenterX + redLineWidth / 2, lineY);
                sliceAnCtx.stroke();
                // Label Insonation Plane
                sliceAnCtx.fillStyle = '#FFFFFF'; // White text
                sliceAnCtx.textAlign = 'left';
                sliceAnCtx.textBaseline = 'top'; // Position label below line
                sliceAnCtx.fillText("Insonation Plane", viewCenterX - redLineWidth / 2, lineY + 3);


            } else {
                 sliceAnCtx.fillStyle = '#555'; sliceAnCtx.font = "12px 'Roboto'"; sliceAnCtx.textAlign = 'center';
                 sliceAnCtx.fillText("Select Nodule Size", sliceAnatomyCanvas.width / 2, sliceAnatomyCanvas.height / 2);
            }
        }

        // function drawStructureAnatomy() removed

        function draw() { // Updated to remove structure anatomy draw call
             if (gameActive || needleState === 'awaiting_entry_point' || needleState === 'awaiting_insertion_angle') {
                 drawUltrasound();
                 // drawStructureAnatomy(); // Removed
                 drawSliceAnatomy();
                 animationFrameId = requestAnimationFrame(draw);
             } else {
                 drawUltrasound();
                 // drawStructureAnatomy(); // Removed
                 drawSliceAnatomy();
                 if (animationFrameId) cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
             }
        }

        // --- Game Logic ---
        function updateMetrics() { // Unchanged
            let adequateP = 0, incompleteP = 0, excessiveP = 0, untouchedP = 100; if (totalNoduleVoxels > 0) { let adequateCount = 0, incompleteCount = 0, excessiveCount = 0; voxels.forEach(voxel => { if (voxel.state === STATE_ADEQUATE) adequateCount++; else if (voxel.state === STATE_INCOMPLETE) incompleteCount++; else if (voxel.state === STATE_EXCESSIVE) excessiveCount++; }); const calcPercent = (count) => Math.round((count / totalNoduleVoxels) * 100); adequateP = calcPercent(adequateCount); incompleteP = calcPercent(incompleteCount); excessiveP = calcPercent(excessiveCount); untouchedP = Math.max(0, 100 - adequateP - incompleteP - excessiveP); } adequatePercentSpan.textContent = adequateP; incompletePercentSpan.textContent = incompleteP; excessivePercentSpan.textContent = excessiveP; untouchedPercentSpan.textContent = untouchedP;
            if (needleState === 'inserted') { const tipConditions = calculateTipConditions(); temperatureValueSpan.textContent = Math.round(tipConditions.temperature); depthValueSpan.textContent = `${currentSlice + 1} / ${maxSlices}`; }
            else { temperatureValueSpan.textContent = '--'; depthValueSpan.textContent = '-- / --'; }
        }

        function updateVoxelTemperatures() { // Unchanged
             if (!gameActive || needleState !== 'inserted') return;
             voxels.forEach(v => v.prevTemperature = v.temperature);
             const tempChanges = new Array(voxels.length).fill(0);
             const p1 = { x: needlePos.x - Math.cos(needleAngle) * ACTIVE_ELECTRODE_LENGTH, y: needlePos.y - Math.sin(needleAngle) * ACTIVE_ELECTRODE_LENGTH, z: currentSlice * voxelSize };
             const p2 = { x: needlePos.x, y: needlePos.y, z: currentSlice * voxelSize };
             voxels.forEach((voxel, index) => { let directHeatChange = 0; let coolingChange = 0; let conductionChange = 0; let heatedOnCurrentSlice = false; if (rfActive) { const voxelCenter = { x: voxel.x + voxel.size / 2, y: voxel.y + voxel.size / 2, z: voxel.z * voxelSize }; const distanceToSegment = distancePointToLineSegment3D(voxelCenter, p1, p2); if (distanceToSegment < BASE_HEAT_SPREAD_RADIUS) { const heatFactor = Math.max(0, 1 - (distanceToSegment / BASE_HEAT_SPREAD_RADIUS)); directHeatChange = heatFactor * (power / 50) * TEMP_INCREASE_RATE; if (voxel.z === currentSlice) { heatedOnCurrentSlice = true; } } } if (!heatedOnCurrentSlice) { coolingChange = -TEMP_DECREASE_RATE; }
             const neighbors = getNeighbors(voxel); let sumNeighborTempDiff = 0; neighbors.forEach(neighbor => { sumNeighborTempDiff += (neighbor.prevTemperature - voxel.prevTemperature); }); if (neighbors.length > 0) { conductionChange = THERMAL_DIFFUSIVITY * (sumNeighborTempDiff / neighbors.length); } tempChanges[index] = directHeatChange + coolingChange + conductionChange; });
             voxels.forEach((voxel, index) => { voxel.temperature += tempChanges[index]; voxel.temperature = Math.max(BODY_TEMP, Math.min(MAX_TEMP, voxel.temperature)); });
        }


        function updateAblationProgress() { // Unchanged
            if (!gameActive || needleState !== 'inserted') return;
            voxels.forEach(voxel => { // Update state for ALL voxels
                if (voxel.temperature >= EFFECTIVE_TEMP_THRESHOLD && ABLATION_RATE_FACTOR > 0) { const tempEffectiveness = (voxel.temperature - EFFECTIVE_TEMP_THRESHOLD) / (MAX_TEMP - EFFECTIVE_TEMP_THRESHOLD); voxel.ablationProgress += Math.max(0, tempEffectiveness) * ABLATION_RATE_FACTOR; }
                if (voxel.state === STATE_EXCESSIVE || voxel.temperature >= MAX_TEMP || (ABLATION_RATE_FACTOR > 0 && voxel.ablationProgress >= EXCESSIVE_THRESHOLD)) { voxel.state = STATE_EXCESSIVE; }
                else if (voxel.state === STATE_ADEQUATE || voxel.temperature >= EFFECTIVE_TEMP_THRESHOLD) { voxel.state = STATE_ADEQUATE; }
                else if (voxel.temperature > BODY_TEMP) { voxel.state = STATE_INCOMPLETE; }
                else { voxel.state = STATE_UNTOUCHED; }
            });
            // Complication checks
            let isNearCritical = false;
            let isOutsideTarget = false;
            let warningMsg = '';
            if (nodule) { nearbyStructures.forEach(struct => { let distance = Infinity; const needleTipRadius = 2; if (struct.type === 'circle') { const dx = needlePos.x - struct.cx; const dy = needlePos.y - struct.cy; if (Math.sqrt(dx*dx + dy*dy) < (struct.radius + needleTipRadius)) { distance = 0; } } else if (struct.type === 'rect') { const rectX = struct.cx - struct.width / 2; const rectY = struct.cy - struct.height / 2; if (needlePos.x + needleTipRadius > rectX && needlePos.x - needleTipRadius < rectX + struct.width && needlePos.y + needleTipRadius > rectY && needlePos.y - needleTipRadius < rectY + struct.height) { distance = 0; } } if (distance === 0) { isNearCritical = true; warningMsg = `WARNING: Needle near ${struct.name}!`; } }); const sliceRatio = 1 - Math.abs(currentSlice - Math.floor(maxSlices / 2)) / (maxSlices / 2); const sliceRadius = nodule.radius * Math.sqrt(Math.max(0, sliceRatio)); const distFromNoduleCenter = Math.sqrt(Math.pow(needlePos.x - nodule.x, 2) + Math.pow(needlePos.y - nodule.y, 2)); const safeRadius = sliceRadius + voxelSize; if (distFromNoduleCenter > safeRadius && rfActive) { isOutsideTarget = true; if (!isNearCritical) { warningMsg = 'WARNING: Ablating outside target zone!'; } } }
            warningTextSpan.textContent = warningMsg;
            if (!warningMsg) { removeNeedleButton.classList.add('hidden'); }
        }


        let gameLogicInterval = null; // Unchanged
        function gameLoop() { if (!gameActive) { if (gameLogicInterval) { clearInterval(gameLogicInterval); gameLogicInterval = null; } return; } updateVoxelTemperatures(); updateAblationProgress(); updateMetrics(); }

        // Chart Functions Removed

        function startGame() { // Unchanged
            if (gameActive || needleState !== 'idle' || !selectedNoduleRadius) return; needleState = 'awaiting_entry_point'; instructionText.textContent = 'Click Nodule Slice View to Select Entry Point'; startButton.disabled = true; resetButton.disabled = false; noduleButtons.forEach(btn => btn.disabled = true); if (!animationFrameId) animationFrameId = requestAnimationFrame(draw);
        }
        function resetForReEntry() { // Updated to handle new warning area
             gameActive = false; rfActive = false; needleState = 'awaiting_entry_point'; entryPoint = null; pivotPoint = null; initialInsertionAngle = null; needlePos = { x: -100, y: -100 }; instructionText.textContent = 'Needle Retracted. Select New Entry Point.'; rfButton.disabled = true; rfButton.classList.remove('on'); powerSlider.disabled = true;
             warningTextSpan.textContent = ''; // Clear warning text
             removeNeedleButton.classList.add('hidden'); // Hide button
             if (gameLogicInterval) { clearInterval(gameLogicInterval); gameLogicInterval = null; }
             isNeedleOnTargetVertically = false; // Reset vertical check flag
             updateMetrics(); draw();
        }
        function endGame(manualReset = false) { // Unchanged
             gameActive = false; rfActive = false; if (gameLogicInterval) { clearInterval(gameLogicInterval); gameLogicInterval = null; } if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } if (!manualReset && totalNoduleVoxels > 0) { let adequateCount = 0, incompleteCount = 0, excessiveCount = 0; voxels.forEach(voxel => { if (voxel.state === STATE_ADEQUATE) adequateCount++; else if (voxel.state === STATE_INCOMPLETE) incompleteCount++; else if (voxel.state === STATE_EXCESSIVE) excessiveCount++; }); const adequateP = Math.round((adequateCount / totalNoduleVoxels) * 100); const incompleteP = Math.round((incompleteCount / totalNoduleVoxels) * 100); const excessiveP = Math.round((excessiveCount / totalNoduleVoxels) * 100);
                 let message = "Procedure Complete!"; message += `\n\n--- Final Ablation ---`; message += `\nAdequate: ${adequateP}%\nIncomplete: ${incompleteP}%\nExcessive: ${excessiveP}%`; showMessage(message); } if (manualReset) { hideMessage(); selectedNoduleRadius = null; initGame(true); } else { rfButton.disabled = true; powerSlider.disabled = true; resetButton.disabled = false; startButton.disabled = true; noduleButtons.forEach(btn => btn.disabled = true); }
        }

        // Updated showMessage to handle different content types
        function showMessage(content) {
            messageText.innerHTML = content; // Use innerHTML to allow basic formatting
            messageBox.style.display = 'block';
        }
        function hideMessage() { messageBox.style.display = 'none'; } // Unchanged
        function toggleRF() { if (!gameActive || needleState !== 'inserted') return; rfActive = !rfActive; rfButton.textContent = rfActive ? 'RF ON' : 'RF OFF'; rfButton.classList.toggle('on', rfActive); if (!rfActive) { warningTextSpan.textContent = ''; removeNeedleButton.classList.add('hidden'); } } // Unchanged

        // --- Event Listeners ---

        // Entry Point Selection now on Slice Anatomy Canvas
        sliceAnatomyCanvas.addEventListener('click', (e) => {
             if (needleState !== 'awaiting_entry_point' || !nodule) return;
             const rect = sliceAnatomyCanvas.getBoundingClientRect();
             const clickX = e.clientX - rect.left;
             const clickY = e.clientY - rect.top;
             entryPoint = { x: clickX, y: clickY };

             // Check vertical alignment
             const viewCenterY = sliceAnatomyCanvas.height / 2;
             const maxDrawRadius = sliceAnatomyCanvas.height / 2 - 15;
             const maxPossibleNoduleRadius = 125;
             const radiusScaleFactor = maxDrawRadius / maxPossibleNoduleRadius;
             const mainDrawRadius = selectedNoduleRadius * radiusScaleFactor;
             let lineY = viewCenterY;
             if (maxSlices > 1) { const relativeDepth = (currentSlice - (maxSlices - 1) / 2) / (maxSlices / 2); lineY = viewCenterY + relativeDepth * mainDrawRadius; }
             const verticalDistance = Math.abs(entryPoint.y - lineY);
             const verticalThreshold = 10;
             isNeedleOnTargetVertically = (verticalDistance <= verticalThreshold);

             // If off target vertically, show warning and button, then stop
             if (!isNeedleOnTargetVertically) {
                 warningTextSpan.textContent = "Entry point too far from current slice. Please re-select.";
                 removeNeedleButton.classList.remove('hidden');
                 pivotPoint = null; // Don't set pivot point
                 drawSliceAnatomy(); drawUltrasound();
                 return; // Stop processing this click
             }

             // --- If on target vertically ---
             warningTextSpan.textContent = ''; // Clear warning
             removeNeedleButton.classList.add('hidden'); // Hide button
             pivotPoint = { x: (clickX / sliceAnatomyCanvas.width) * ultrasoundCanvas.width, y: 15 };
             pivotPoint.x = Math.max(0, Math.min(ultrasoundCanvas.width, pivotPoint.x)); // Clamp
             needleState = 'awaiting_insertion_angle';
             instructionText.textContent = 'Click Ultrasound View to Set Insertion Angle';
             drawSliceAnatomy(); drawUltrasound();
        });


        ultrasoundCanvas.addEventListener('click', (e) => { if (needleState !== 'awaiting_insertion_angle' || !pivotPoint) return; const rect = ultrasoundCanvas.getBoundingClientRect(); const clickX = e.clientX - rect.left; const clickY = e.clientY - rect.top; const dx = clickX - pivotPoint.x; const dy = clickY - pivotPoint.y; initialInsertionAngle = Math.atan2(dy, dx); initialInsertionAngle = Math.max(0.1, Math.min(Math.PI - 0.1, initialInsertionAngle)); needleAngle = initialInsertionAngle; needleLength = retractionThreshold + 5; needlePos.x = pivotPoint.x + Math.cos(needleAngle) * needleLength; needlePos.y = pivotPoint.y + Math.sin(needleAngle) * needleLength; needleState = 'inserted'; instructionText.textContent = 'Needle Inserted. Aim and Ablate.'; gameActive = true; rfButton.disabled = false; powerSlider.disabled = false; if (gameLogicInterval) clearInterval(gameLogicInterval); gameLogicInterval = setInterval(gameLoop, 50); if (!animationFrameId) animationFrameId = requestAnimationFrame(draw); });
        ultrasoundCanvas.addEventListener('mousemove', (e) => { // Unchanged
            if (!gameActive || needleState !== 'inserted' || !pivotPoint) return;
            const rect = ultrasoundCanvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const dx = mouseX - pivotPoint.x; const dy = mouseY - pivotPoint.y;
            let desiredAngle = Math.atan2(dy, dx); let desiredLength = Math.sqrt(dx*dx + dy*dy);
            if (desiredLength < retractionThreshold) { resetForReEntry(); return; }
            needleLength = desiredLength;
            if (initialInsertionAngle !== null) {
                const insertionDepth = Math.max(0, needleLength - retractionThreshold);
                const depthRatio = Math.min(1, insertionDepth / (MAX_DEPTH_FOR_LIMIT_CHANGE - retractionThreshold));
                const currentAngleLimit = MAX_ANGLE_LIMIT - depthRatio * (MAX_ANGLE_LIMIT - MIN_ANGLE_LIMIT); // Correct interpolation
                let angleDiff = desiredAngle - initialInsertionAngle;
                while (angleDiff <= -Math.PI) angleDiff += 2 * Math.PI; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                angleDiff = Math.max(-currentAngleLimit, Math.min(currentAngleLimit, angleDiff));
                needleAngle = initialInsertionAngle + angleDiff;
            } else { needleAngle = desiredAngle; }
            needleAngle = Math.max(0.1, Math.min(Math.PI - 0.1, needleAngle));
            needlePos.x = pivotPoint.x + Math.cos(needleAngle) * needleLength; needlePos.y = pivotPoint.y + Math.sin(needleAngle) * needleLength;
            needlePos.x = Math.max(0, Math.min(ultrasoundCanvas.width, needlePos.x)); needlePos.y = Math.max(0, Math.min(ultrasoundCanvas.height, needlePos.y));
        });
        rfButton.addEventListener('click', toggleRF);

        // Obscuring Toggle Button Listener
        toggleObscuringButton.addEventListener('click', () => {
            obscuringEffectActive = !obscuringEffectActive;
            toggleObscuringButton.textContent = obscuringEffectActive ? 'SHADOWING ON' : 'SHADOWING OFF';
            drawUltrasound(); // Unconditional redraw
        });

        // Grid/Outline Toggle Button Listener
        toggleGridButton.addEventListener('click', () => {
            showGridAndOutline = !showGridAndOutline;
            toggleGridButton.textContent = showGridAndOutline ? 'GRID ON' : 'GRID OFF';
            drawUltrasound();
        });

        // Remove Needle Button Listener
        removeNeedleButton.addEventListener('click', () => {
            // Resetting entry allows user to click again on slice view
            needleState = 'awaiting_entry_point';
            entryPoint = null;
            pivotPoint = null;
            isNeedleOnTargetVertically = false;
            warningTextSpan.textContent = ''; // Clear specific warning
            removeNeedleButton.classList.add('hidden'); // Hide self
            instructionText.textContent = 'Click Nodule Slice View to Select Entry Point';
            draw(); // Redraw relevant views
        });


        // Info Button Listener Removed

        window.addEventListener('keydown', (e) => { // Unchanged
             if (needleState === 'awaiting_entry_point' || needleState === 'awaiting_insertion_angle') {
                 if (e.code === 'ArrowUp') {
                     e.preventDefault();
                     currentSlice = Math.max(0, currentSlice - 1);
                     updateMetrics(); drawSliceAnatomy(); drawUltrasound();
                 } else if (e.code === 'ArrowDown') {
                     e.preventDefault();
                     currentSlice = Math.min(maxSlices - 1, currentSlice + 1);
                     updateMetrics(); drawSliceAnatomy(); drawUltrasound();
                 }
             }
             if (gameActive && needleState === 'inserted') {
                 if (e.code === 'Space') {
                     e.preventDefault();
                     toggleRF();
                 }
             }
         });
        powerSlider.addEventListener('input', (e) => { // Unchanged
             power = parseInt(e.target.value);
             powerValueSpan.textContent = power;
        });
        noduleButtons.forEach(button => { button.addEventListener('click', () => {
            if (needleState === 'inserted') return;
            startButton.disabled = false; // Enable start button FIRST
            selectedNoduleRadius = parseInt(button.getAttribute('data-size'));
            noduleButtons.forEach(btn => btn.classList.remove('selected'));
            button.classList.add('selected');
            createNoduleAndVoxels(); // This calls draw() which might overwrite instruction text
            // Set instruction text AFTER createNoduleAndVoxels
            if (needleState === 'idle') { instructionText.textContent = 'Click Start'; }
            else if (needleState === 'awaiting_entry_point') { instructionText.textContent = 'Click Nodule Slice View to Select Entry Point'; }
            else if (needleState === 'awaiting_insertion_angle') { instructionText.textContent = 'Click Ultrasound View to Set Insertion Angle'; }
         }); });
        startButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', () => { endGame(true); });
        closeMessageButton.addEventListener('click', hideMessage);
        window.onload = () => { /* initializeChart(); */ initGame(); };

    </script>
</body>
</html>
